{"version":3,"file":"index-BdoV8z1p.js","sources":["../../../../node_modules/.pnpm/image-meta@0.2.1/node_modules/image-meta/dist/index.mjs"],"sourcesContent":["const decoder = new TextDecoder();\nconst toUTF8String = (input, start = 0, end = input.length) => decoder.decode(input.slice(start, end));\nconst toHexString = (input, start = 0, end = input.length) => input.slice(start, end).reduce((memo, i) => memo + (\"0\" + i.toString(16)).slice(-2), \"\");\nconst readInt16LE = (input, offset = 0) => {\n  const val = input[offset] + input[offset + 1] * 2 ** 8;\n  return val | (val & 2 ** 15) * 131070;\n};\nconst readUInt16BE = (input, offset = 0) => input[offset] * 2 ** 8 + input[offset + 1];\nconst readUInt16LE = (input, offset = 0) => input[offset] + input[offset + 1] * 2 ** 8;\nconst readUInt24LE = (input, offset = 0) => input[offset] + input[offset + 1] * 2 ** 8 + input[offset + 2] * 2 ** 16;\nconst readInt32LE = (input, offset = 0) => input[offset] + input[offset + 1] * 2 ** 8 + input[offset + 2] * 2 ** 16 + (input[offset + 3] << 24);\nconst readUInt32BE = (input, offset = 0) => input[offset] * 2 ** 24 + input[offset + 1] * 2 ** 16 + input[offset + 2] * 2 ** 8 + input[offset + 3];\nconst readUInt32LE = (input, offset = 0) => input[offset] + input[offset + 1] * 2 ** 8 + input[offset + 2] * 2 ** 16 + input[offset + 3] * 2 ** 24;\nconst methods = {\n  readUInt16BE,\n  readUInt16LE,\n  readUInt32BE,\n  readUInt32LE\n};\nfunction readUInt(input, bits, offset, isBigEndian) {\n  offset = offset || 0;\n  const endian = isBigEndian ? \"BE\" : \"LE\";\n  const methodName = \"readUInt\" + bits + endian;\n  return methods[methodName](input, offset);\n}\n\nconst BMP = {\n  validate: (input) => toUTF8String(input, 0, 2) === \"BM\",\n  calculate: (input) => ({\n    height: Math.abs(readInt32LE(input, 22)),\n    width: readUInt32LE(input, 18)\n  })\n};\n\nconst TYPE_ICON = 1;\nconst SIZE_HEADER$1 = 2 + 2 + 2;\nconst SIZE_IMAGE_ENTRY = 1 + 1 + 1 + 1 + 2 + 2 + 4 + 4;\nfunction getSizeFromOffset(input, offset) {\n  const value = input[offset];\n  return value === 0 ? 256 : value;\n}\nfunction getImageSize$1(input, imageIndex) {\n  const offset = SIZE_HEADER$1 + imageIndex * SIZE_IMAGE_ENTRY;\n  return {\n    height: getSizeFromOffset(input, offset + 1),\n    width: getSizeFromOffset(input, offset)\n  };\n}\nconst ICO = {\n  validate(input) {\n    const reserved = readUInt16LE(input, 0);\n    const imageCount = readUInt16LE(input, 4);\n    if (reserved !== 0 || imageCount === 0) {\n      return false;\n    }\n    const imageType = readUInt16LE(input, 2);\n    return imageType === TYPE_ICON;\n  },\n  calculate(input) {\n    const nbImages = readUInt16LE(input, 4);\n    const imageSize = getImageSize$1(input, 0);\n    if (nbImages === 1) {\n      return imageSize;\n    }\n    const imgs = [imageSize];\n    for (let imageIndex = 1; imageIndex < nbImages; imageIndex += 1) {\n      imgs.push(getImageSize$1(input, imageIndex));\n    }\n    return {\n      height: imageSize.height,\n      images: imgs,\n      width: imageSize.width\n    };\n  }\n};\n\nconst TYPE_CURSOR = 2;\nconst CUR = {\n  validate(input) {\n    const reserved = readUInt16LE(input, 0);\n    const imageCount = readUInt16LE(input, 4);\n    if (reserved !== 0 || imageCount === 0) {\n      return false;\n    }\n    const imageType = readUInt16LE(input, 2);\n    return imageType === TYPE_CURSOR;\n  },\n  calculate: (input) => ICO.calculate(input)\n};\n\nconst DDS = {\n  validate: (input) => readUInt32LE(input, 0) === 542327876,\n  calculate: (input) => ({\n    height: readUInt32LE(input, 12),\n    width: readUInt32LE(input, 16)\n  })\n};\n\nconst gifRegexp = /^GIF8[79]a/;\nconst GIF = {\n  validate: (input) => gifRegexp.test(toUTF8String(input, 0, 6)),\n  calculate: (input) => ({\n    height: readUInt16LE(input, 8),\n    width: readUInt16LE(input, 6)\n  })\n};\n\nconst SIZE_HEADER = 4 + 4;\nconst FILE_LENGTH_OFFSET = 4;\nconst ENTRY_LENGTH_OFFSET = 4;\nconst ICON_TYPE_SIZE = {\n  ICON: 32,\n  \"ICN#\": 32,\n  // m => 16 x 16\n  \"icm#\": 16,\n  icm4: 16,\n  icm8: 16,\n  // s => 16 x 16\n  \"ics#\": 16,\n  ics4: 16,\n  ics8: 16,\n  is32: 16,\n  s8mk: 16,\n  icp4: 16,\n  // l => 32 x 32\n  icl4: 32,\n  icl8: 32,\n  il32: 32,\n  l8mk: 32,\n  icp5: 32,\n  ic11: 32,\n  // h => 48 x 48\n  ich4: 48,\n  ich8: 48,\n  ih32: 48,\n  h8mk: 48,\n  // . => 64 x 64\n  icp6: 64,\n  ic12: 32,\n  // t => 128 x 128\n  it32: 128,\n  t8mk: 128,\n  ic07: 128,\n  // . => 256 x 256\n  ic08: 256,\n  ic13: 256,\n  // . => 512 x 512\n  ic09: 512,\n  ic14: 512,\n  // . => 1024 x 1024\n  ic10: 1024\n};\nfunction readImageHeader(input, imageOffset) {\n  const imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET;\n  return [\n    toUTF8String(input, imageOffset, imageLengthOffset),\n    readUInt32BE(input, imageLengthOffset)\n  ];\n}\nfunction getImageSize(type) {\n  const size = ICON_TYPE_SIZE[type];\n  return { width: size, height: size, type };\n}\nconst ICNS = {\n  validate: (input) => toUTF8String(input, 0, 4) === \"icns\",\n  calculate(input) {\n    const inputLength = input.length;\n    const fileLength = readUInt32BE(input, FILE_LENGTH_OFFSET);\n    let imageOffset = SIZE_HEADER;\n    let imageHeader = readImageHeader(input, imageOffset);\n    let imageSize = getImageSize(imageHeader[0]);\n    imageOffset += imageHeader[1];\n    if (imageOffset === fileLength) {\n      return imageSize;\n    }\n    const result = {\n      height: imageSize.height,\n      images: [imageSize],\n      width: imageSize.width\n    };\n    while (imageOffset < fileLength && imageOffset < inputLength) {\n      imageHeader = readImageHeader(input, imageOffset);\n      imageSize = getImageSize(imageHeader[0]);\n      imageOffset += imageHeader[1];\n      result.images.push(imageSize);\n    }\n    return result;\n  }\n};\n\nconst J2C = {\n  // TODO: this doesn't seem right. SIZ marker doesn't have to be right after the SOC\n  validate: (input) => toHexString(input, 0, 4) === \"ff4fff51\",\n  calculate: (input) => ({\n    height: readUInt32BE(input, 12),\n    width: readUInt32BE(input, 8)\n  })\n};\n\nconst BoxTypes = {\n  ftyp: \"66747970\",\n  ihdr: \"69686472\",\n  jp2h: \"6a703268\",\n  jp__: \"6a502020\",\n  rreq: \"72726571\",\n  xml_: \"786d6c20\"\n};\nconst calculateRREQLength = (box) => {\n  const unit = box[0];\n  let offset = 1 + 2 * unit;\n  const numStdFlags = readUInt16BE(box, offset);\n  const flagsLength = numStdFlags * (2 + unit);\n  offset = offset + 2 + flagsLength;\n  const numVendorFeatures = readUInt16BE(box, offset);\n  const featuresLength = numVendorFeatures * (16 + unit);\n  return offset + 2 + featuresLength;\n};\nconst parseIHDR = (box) => {\n  return {\n    height: readUInt32BE(box, 4),\n    width: readUInt32BE(box, 8)\n  };\n};\nconst JP2 = {\n  validate(input) {\n    const signature = toHexString(input, 4, 8);\n    const signatureLength = readUInt32BE(input, 0);\n    if (signature !== BoxTypes.jp__ || signatureLength < 1) {\n      return false;\n    }\n    const ftypeBoxStart = signatureLength + 4;\n    const ftypBoxLength = readUInt32BE(input, signatureLength);\n    const ftypBox = input.slice(ftypeBoxStart, ftypeBoxStart + ftypBoxLength);\n    return toHexString(ftypBox, 0, 4) === BoxTypes.ftyp;\n  },\n  calculate(input) {\n    const signatureLength = readUInt32BE(input, 0);\n    const ftypBoxLength = readUInt16BE(input, signatureLength + 2);\n    let offset = signatureLength + 4 + ftypBoxLength;\n    const nextBoxType = toHexString(input, offset, offset + 4);\n    switch (nextBoxType) {\n      case BoxTypes.rreq: {\n        const MAGIC = 4;\n        offset = offset + 4 + MAGIC + calculateRREQLength(input.slice(offset + 4));\n        return parseIHDR(input.slice(offset + 8, offset + 24));\n      }\n      case BoxTypes.jp2h: {\n        return parseIHDR(input.slice(offset + 8, offset + 24));\n      }\n      default: {\n        throw new TypeError(\n          \"Unsupported header found: \" + toUTF8String(input, offset, offset + 4)\n        );\n      }\n    }\n  }\n};\n\nconst EXIF_MARKER = \"45786966\";\nconst APP1_DATA_SIZE_BYTES = 2;\nconst EXIF_HEADER_BYTES = 6;\nconst TIFF_BYTE_ALIGN_BYTES = 2;\nconst BIG_ENDIAN_BYTE_ALIGN = \"4d4d\";\nconst LITTLE_ENDIAN_BYTE_ALIGN = \"4949\";\nconst IDF_ENTRY_BYTES = 12;\nconst NUM_DIRECTORY_ENTRIES_BYTES = 2;\nfunction isEXIF(input) {\n  return toHexString(input, 2, 6) === EXIF_MARKER;\n}\nfunction extractSize(input, index) {\n  return {\n    height: readUInt16BE(input, index),\n    width: readUInt16BE(input, index + 2)\n  };\n}\nfunction extractOrientation(exifBlock, isBigEndian) {\n  const idfOffset = 8;\n  const offset = EXIF_HEADER_BYTES + idfOffset;\n  const idfDirectoryEntries = readUInt(exifBlock, 16, offset, isBigEndian);\n  for (let directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {\n    const start = offset + NUM_DIRECTORY_ENTRIES_BYTES + directoryEntryNumber * IDF_ENTRY_BYTES;\n    const end = start + IDF_ENTRY_BYTES;\n    if (start > exifBlock.length) {\n      return;\n    }\n    const block = exifBlock.slice(start, end);\n    const tagNumber = readUInt(block, 16, 0, isBigEndian);\n    if (tagNumber === 274) {\n      const dataFormat = readUInt(block, 16, 2, isBigEndian);\n      if (dataFormat !== 3) {\n        return;\n      }\n      const numberOfComponents = readUInt(block, 32, 4, isBigEndian);\n      if (numberOfComponents !== 1) {\n        return;\n      }\n      return readUInt(block, 16, 8, isBigEndian);\n    }\n  }\n}\nfunction validateExifBlock(input, index) {\n  const exifBlock = input.slice(APP1_DATA_SIZE_BYTES, index);\n  const byteAlign = toHexString(\n    exifBlock,\n    EXIF_HEADER_BYTES,\n    EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES\n  );\n  const isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;\n  const isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;\n  if (isBigEndian || isLittleEndian) {\n    return extractOrientation(exifBlock, isBigEndian);\n  }\n}\nfunction validateInput(input, index) {\n  if (index > input.length) {\n    throw new TypeError(\"Corrupt JPG, exceeded buffer limits\");\n  }\n  if (input[index] !== 255) {\n    throw new TypeError(\"Invalid JPG, marker table corrupted\");\n  }\n}\nconst JPG = {\n  validate: (input) => toHexString(input, 0, 2) === \"ffd8\",\n  calculate(input) {\n    input = input.slice(4);\n    let orientation;\n    let next;\n    while (input.length > 0) {\n      const i = readUInt16BE(input, 0);\n      if (isEXIF(input)) {\n        orientation = validateExifBlock(input, i);\n      }\n      validateInput(input, i);\n      next = input[i + 1];\n      if (next === 192 || next === 193 || next === 194) {\n        const size = extractSize(input, i + 5);\n        if (!orientation) {\n          return size;\n        }\n        return {\n          height: size.height,\n          orientation,\n          width: size.width\n        };\n      }\n      input = input.slice(i + 2);\n    }\n    throw new TypeError(\"Invalid JPG, no size found\");\n  }\n};\n\nconst KTX = {\n  validate: (input) => toUTF8String(input, 1, 7) === \"KTX 11\",\n  calculate: (input) => ({\n    height: readUInt32LE(input, 40),\n    width: readUInt32LE(input, 36)\n  })\n};\n\nconst pngSignature = \"PNG\\r\\n\u001a\\n\";\nconst pngImageHeaderChunkName = \"IHDR\";\nconst pngFriedChunkName = \"CgBI\";\nconst PNG = {\n  validate(input) {\n    if (pngSignature === toUTF8String(input, 1, 8)) {\n      let chunkName = toUTF8String(input, 12, 16);\n      if (chunkName === pngFriedChunkName) {\n        chunkName = toUTF8String(input, 28, 32);\n      }\n      if (chunkName !== pngImageHeaderChunkName) {\n        throw new TypeError(\"Invalid PNG\");\n      }\n      return true;\n    }\n    return false;\n  },\n  calculate(input) {\n    if (toUTF8String(input, 12, 16) === pngFriedChunkName) {\n      return {\n        height: readUInt32BE(input, 36),\n        width: readUInt32BE(input, 32)\n      };\n    }\n    return {\n      height: readUInt32BE(input, 20),\n      width: readUInt32BE(input, 16)\n    };\n  }\n};\n\nconst PNMTypes = {\n  P1: \"pbm/ascii\",\n  P2: \"pgm/ascii\",\n  P3: \"ppm/ascii\",\n  P4: \"pbm\",\n  P5: \"pgm\",\n  P6: \"ppm\",\n  P7: \"pam\",\n  PF: \"pfm\"\n};\nconst handlers = {\n  default: (lines) => {\n    let dimensions = [];\n    while (lines.length > 0) {\n      const line = lines.shift();\n      if (line[0] === \"#\") {\n        continue;\n      }\n      dimensions = line.split(\" \");\n      break;\n    }\n    if (dimensions.length === 2) {\n      return {\n        height: Number.parseInt(dimensions[1], 10),\n        width: Number.parseInt(dimensions[0], 10)\n      };\n    } else {\n      throw new TypeError(\"Invalid PNM\");\n    }\n  },\n  pam: (lines) => {\n    const size = {};\n    while (lines.length > 0) {\n      const line = lines.shift();\n      if (line.length > 16 || (line.codePointAt(0) || 0) > 128) {\n        continue;\n      }\n      const [key, value] = line.split(\" \");\n      if (key && value) {\n        size[key.toLowerCase()] = Number.parseInt(value, 10);\n      }\n      if (size.height && size.width) {\n        break;\n      }\n    }\n    if (size.height && size.width) {\n      return {\n        height: size.height,\n        width: size.width\n      };\n    } else {\n      throw new TypeError(\"Invalid PAM\");\n    }\n  }\n};\nconst PNM = {\n  validate: (input) => toUTF8String(input, 0, 2) in PNMTypes,\n  calculate(input) {\n    const signature = toUTF8String(input, 0, 2);\n    const type = PNMTypes[signature];\n    const lines = toUTF8String(input, 3).split(/[\\n\\r]+/);\n    const handler = handlers[type] || handlers.default;\n    return handler(lines);\n  }\n};\n\nconst PSD = {\n  validate: (input) => toUTF8String(input, 0, 4) === \"8BPS\",\n  calculate: (input) => ({\n    height: readUInt32BE(input, 14),\n    width: readUInt32BE(input, 18)\n  })\n};\n\nconst svgReg = /<svg\\s([^\"'>]|\"[^\"]*\"|'[^']*')*>/;\nconst extractorRegExps = {\n  height: /\\sheight=([\"'])([^%]+?)\\1/,\n  root: svgReg,\n  viewbox: /\\sviewbox=([\"'])(.+?)\\1/i,\n  width: /\\swidth=([\"'])([^%]+?)\\1/\n};\nconst INCH_CM = 2.54;\nconst units = {\n  in: 96,\n  cm: 96 / INCH_CM,\n  em: 16,\n  ex: 8,\n  m: 96 / INCH_CM * 100,\n  mm: 96 / INCH_CM / 10,\n  pc: 96 / 72 / 12,\n  pt: 96 / 72,\n  px: 1\n};\nconst unitsReg = new RegExp(\n  `^([0-9.]+(?:e\\\\d+)?)(${Object.keys(units).join(\"|\")})?$`\n);\nfunction parseLength(len) {\n  const m = unitsReg.exec(len);\n  if (!m) {\n    return void 0;\n  }\n  return Math.round(Number(m[1]) * (units[m[2]] || 1));\n}\nfunction parseViewbox(viewbox) {\n  const bounds = viewbox.split(\" \");\n  return {\n    height: parseLength(bounds[3]),\n    width: parseLength(bounds[2])\n  };\n}\nfunction parseAttributes(root) {\n  const width = root.match(extractorRegExps.width);\n  const height = root.match(extractorRegExps.height);\n  const viewbox = root.match(extractorRegExps.viewbox);\n  return {\n    height: height && parseLength(height[2]),\n    viewbox: viewbox && parseViewbox(viewbox[2]),\n    width: width && parseLength(width[2])\n  };\n}\nfunction calculateByDimensions(attrs) {\n  return {\n    height: attrs.height,\n    width: attrs.width\n  };\n}\nfunction calculateByViewbox(attrs, viewbox) {\n  const ratio = viewbox.width / viewbox.height;\n  if (attrs.width) {\n    return {\n      height: Math.floor(attrs.width / ratio),\n      width: attrs.width\n    };\n  }\n  if (attrs.height) {\n    return {\n      height: attrs.height,\n      width: Math.floor(attrs.height * ratio)\n    };\n  }\n  return {\n    height: viewbox.height,\n    width: viewbox.width\n  };\n}\nconst SVG = {\n  // Scan only the first kilo-byte to speed up the check on larger files\n  validate: (input) => svgReg.test(toUTF8String(input, 0, 1e3)),\n  calculate(input) {\n    const root = toUTF8String(input).match(extractorRegExps.root);\n    if (root) {\n      const attrs = parseAttributes(root[0]);\n      if (attrs.width && attrs.height) {\n        return calculateByDimensions(attrs);\n      }\n      if (attrs.viewbox) {\n        return calculateByViewbox(attrs, attrs.viewbox);\n      }\n    }\n    throw new TypeError(\"Invalid SVG\");\n  }\n};\n\nconst TGA = {\n  validate(input) {\n    return readUInt16LE(input, 0) === 0 && readUInt16LE(input, 4) === 0;\n  },\n  calculate(input) {\n    return {\n      height: readUInt16LE(input, 14),\n      width: readUInt16LE(input, 12)\n    };\n  }\n};\n\nfunction readIFD(buffer, isBigEndian) {\n  const ifdOffset = readUInt(buffer, 32, 4, isBigEndian);\n  let bufferSize = 1024;\n  const fileSize = buffer.length;\n  if (ifdOffset + bufferSize > fileSize) {\n    bufferSize = fileSize - ifdOffset - 10;\n  }\n  return buffer.slice(ifdOffset + 2, ifdOffset + 2 + bufferSize);\n}\nfunction readValue(buffer, isBigEndian) {\n  const low = readUInt(buffer, 16, 8, isBigEndian);\n  const high = readUInt(buffer, 16, 10, isBigEndian);\n  return (high << 16) + low;\n}\nfunction nextTag(buffer) {\n  if (buffer.length > 24) {\n    return buffer.slice(12);\n  }\n}\nfunction extractTags(buffer, isBigEndian) {\n  const tags = {};\n  let temp = buffer;\n  while (temp && temp.length > 0) {\n    const code = readUInt(temp, 16, 0, isBigEndian);\n    const type = readUInt(temp, 16, 2, isBigEndian);\n    const length = readUInt(temp, 32, 4, isBigEndian);\n    if (code === 0) {\n      break;\n    } else {\n      if (length === 1 && (type === 3 || type === 4)) {\n        tags[code] = readValue(temp, isBigEndian);\n      }\n      temp = nextTag(temp);\n    }\n  }\n  return tags;\n}\nfunction determineEndianness(input) {\n  const signature = toUTF8String(input, 0, 2);\n  if (signature === \"II\") {\n    return \"LE\";\n  } else if (signature === \"MM\") {\n    return \"BE\";\n  }\n}\nconst signatures = /* @__PURE__ */ new Set([\n  // '492049', // currently not supported\n  \"49492a00\",\n  // Little endian\n  \"4d4d002a\"\n  // Big Endian\n  // '4d4d002a', // BigTIFF > 4GB. currently not supported\n]);\nconst TIFF = {\n  validate: (input) => signatures.has(toHexString(input, 0, 4)),\n  calculate(input) {\n    const isBigEndian = determineEndianness(input) === \"BE\";\n    const ifdBuffer = readIFD(input, isBigEndian);\n    const tags = extractTags(ifdBuffer, isBigEndian);\n    const width = tags[256];\n    const height = tags[257];\n    if (!width || !height) {\n      throw new TypeError(\"Invalid Tiff. Missing tags\");\n    }\n    return { height, width };\n  }\n};\n\nfunction calculateExtended(input) {\n  return {\n    height: 1 + readUInt24LE(input, 7),\n    width: 1 + readUInt24LE(input, 4)\n  };\n}\nfunction calculateLossless(input) {\n  return {\n    height: 1 + ((input[4] & 15) << 10 | input[3] << 2 | (input[2] & 192) >> 6),\n    width: 1 + ((input[2] & 63) << 8 | input[1])\n  };\n}\nfunction calculateLossy(input) {\n  return {\n    height: readInt16LE(input, 8) & 16383,\n    width: readInt16LE(input, 6) & 16383\n  };\n}\nconst WEBP = {\n  validate(input) {\n    const riffHeader = toUTF8String(input, 0, 4) === \"RIFF\";\n    const webpHeader = toUTF8String(input, 8, 12) === \"WEBP\";\n    const vp8Header = toUTF8String(input, 12, 15) === \"VP8\";\n    return riffHeader && webpHeader && vp8Header;\n  },\n  calculate(input) {\n    const chunkHeader = toUTF8String(input, 12, 16);\n    input = input.slice(20, 30);\n    if (chunkHeader === \"VP8X\") {\n      const extendedHeader = input[0];\n      const validStart = (extendedHeader & 192) === 0;\n      const validEnd = (extendedHeader & 1) === 0;\n      if (validStart && validEnd) {\n        return calculateExtended(input);\n      } else {\n        throw new TypeError(\"Invalid WebP\");\n      }\n    }\n    if (chunkHeader === \"VP8 \" && input[0] !== 47) {\n      return calculateLossy(input);\n    }\n    const signature = toHexString(input, 3, 6);\n    if (chunkHeader === \"VP8L\" && signature !== \"9d012a\") {\n      return calculateLossless(input);\n    }\n    throw new TypeError(\"Invalid WebP\");\n  }\n};\n\nconst AVIF = {\n  validate: (input) => toUTF8String(input, 8, 12) === \"avif\",\n  calculate: (input) => {\n    const metaBox = findBox(input, \"meta\");\n    const iprpBox = findBox(\n      input,\n      \"iprp\",\n      metaBox.offset + 12,\n      metaBox.offset + metaBox.size\n    );\n    const ipcoBox = findBox(\n      input,\n      \"ipco\",\n      iprpBox.offset + 8,\n      iprpBox.offset + iprpBox.size\n    );\n    const ispeBox = findBox(\n      input,\n      \"ispe\",\n      ipcoBox.offset + 8,\n      ipcoBox.offset + ipcoBox.size\n    );\n    const width = readUInt32BE(input, ispeBox.offset + 12);\n    const height = readUInt32BE(input, ispeBox.offset + 16);\n    return { width, height };\n  }\n};\nfunction findBox(input, type, startOffset = 0, endOffset = input.length) {\n  for (let offset = startOffset; offset < endOffset; ) {\n    const size = readUInt32BE(input, offset);\n    const boxType = toUTF8String(input, offset + 4, offset + 8);\n    if (boxType === type) {\n      return { offset, size };\n    }\n    if (size <= 0 || offset + size > endOffset) {\n      break;\n    }\n    offset += size;\n  }\n  throw new Error(`${type} box not found`);\n}\n\nconst typeHandlers = {\n  bmp: BMP,\n  cur: CUR,\n  dds: DDS,\n  gif: GIF,\n  icns: ICNS,\n  ico: ICO,\n  j2c: J2C,\n  jp2: JP2,\n  jpg: JPG,\n  ktx: KTX,\n  png: PNG,\n  pnm: PNM,\n  psd: PSD,\n  svg: SVG,\n  tga: TGA,\n  tiff: TIFF,\n  webp: WEBP,\n  avif: AVIF\n};\n\nconst keys = Object.keys(typeHandlers);\nconst firstBytes = {\n  56: \"psd\",\n  66: \"bmp\",\n  68: \"dds\",\n  71: \"gif\",\n  73: \"tiff\",\n  77: \"tiff\",\n  82: \"webp\",\n  105: \"icns\",\n  137: \"png\",\n  255: \"jpg\"\n};\nfunction detector(input) {\n  const byte = input[0];\n  if (byte in firstBytes) {\n    const type = firstBytes[byte];\n    if (type && typeHandlers[type].validate(input)) {\n      return type;\n    }\n  }\n  return keys.find((key) => typeHandlers[key].validate(input));\n}\n\nfunction imageMeta(input) {\n  if (!(input instanceof Uint8Array)) {\n    throw new TypeError(\"Input should be a Uint8Array\");\n  }\n  const type = detector(input);\n  if (type !== void 0 && type in typeHandlers) {\n    const size = typeHandlers[type].calculate(input);\n    if (size !== void 0) {\n      size.type = type;\n      return size;\n    }\n  }\n  throw new TypeError(`Unsupported file type: ${type}`);\n}\n\nexport { imageMeta };\n"],"names":[],"mappings":"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","x_google_ignoreList":[0]}